# -*- coding: utf-8 -*-
"""FastInterpolation4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nGrkjTu84qw8iGNXV4GkvAQMSy-GaZnq
"""

import numpy as np
import time
from collections import defaultdict

class FastSearchArray:
    # arr - a sorted array
    # multi - number of hints points for every original point
    def __init__(self, arr, multi=100):
        self._data = np.asarray(arr)
        self.x0 = self._data[0]
        self.xf = self._data[-1]
        self.r = self.xf - self.x0
        l = len(self._data)
        self.num = int(l * multi)
        self.ratio = self.num / self.r
        # bulding the hint array
        values = np.linspace(self.x0, self.x0 + self.r, num=self.num+1, endpoint=True)
        self.hint = np.searchsorted(self._data, values).astype(int)
        self.hint[-1] = self.hint[-2]

        # testing the hint array
        test_points = np.linspace(self.x0,self.xf,self.num*100)
        ground_true = np.searchsorted(arr,test_points)

        test_values = self.hint[np.array(self.ratio * (test_points - self.x0),dtype=int)]
        cancel = test_points[ground_true!=test_values]
        # marking failed test points
        self.hint[np.array(self.ratio * (cancel - self.x0),dtype=int)] = -1

        print(f'hint valid persentage {np.count_nonzero(self.hint==-1)/self.hint.size}')

    def hintsearch(self, p):
      res = self.hint[int(self.ratio * (p - self.x0))]
      if res ==-1:
        return np.searchsorted(self._data,p)
      return res



if __name__ == "__main__":
    n = 3
    start_x = 0.0
    end_x   = 10.0
    num     = 10**n

    xs = np.sort(np.random.uniform(low=start_x, high=end_x, size=num))
    xs[0] = start_x; xs[-1] = end_x

    arr = FastSearchArray(xs)

    times = defaultdict(lambda: 0)

    test_points = np.sort(np.random.uniform(low=start_x, high=end_x, size=30000))


    # 3) Evaluate and measure time
    for x0 in test_points:
        # -- A) Direct NumPy searchsorted
        start_time = time.time()
        val_searchsorted = np.searchsorted(xs, x0)
        end_time = time.time()
        times['searchsorted'] += (end_time - start_time)

        # -- B) Custom hintsearch
        start_time = time.time()
        val_hint = arr.hintsearch(x0)
        end_time = time.time()
        times['hintsearch'] += (end_time - start_time)

        if val_searchsorted - val_hint > 1e-8:
            print(f"Warning: mismatch at x0={x0} -> searchsorted={val_searchsorted}, hintsearch={val_hint}")

    # 4) Average times per interpolation call in case we want to print it
    n_tests = len(test_points)
    for k in times.keys():
        times[k] /= n_tests

    speedup = (times['searchsorted'] / times['hintsearch']
               if times['hintsearch'] != 0 else float('inf'))

    print("Speedup (searchsorted / hintsearch):", speedup)

9.993148125982389*100000/ 9.987115633484322



dir([])

np.float64

np.linspace(0, 1, 5, endpoint=True)

class FastInterp:
    def __init__(self, x_points, y_points):
        self.x_points = np.asarray(x_points)
        self.y_points = np.asarray(y_points)

        # Create our fast-search object for the x array
        self.x_array = FastSearchArray(self.x_points)
        # (you can tune multi=... for best performance)

        # Number of points
        self.num_points = len(self.x_points)

        # Precompute slope/intercept for each adjacent pair
        # slopes[i] corresponds to slope in [x_points[i], x_points[i+1]]
        self.array_m = np.zeros(self.num_points - 1)
        self.array_c = np.zeros(self.num_points - 1)

        dx = np.diff(self.x_points)
        dy = np.diff(self.y_points)
        self.array_m = dy / dx
        self.array_c = self.y_points[:-1] - self.array_m * self.x_points[:-1]




# | | * | | * | | |

    def __call__(self, x):
        i = self.x_array.hintsearch(x)-1
        return self.array_m[i] * x + self.array_c[i]

##############################################################################
# A small test script comparing to scipy.interpolate
##############################################################################
if __name__ == "__main__1":
    from scipy.interpolate import interp1d

    # Build x and y data
    start_x = 0.1
    end_x   = 10.0
    n_points = 100  # for example


    # x_points = np.linspace(start_x, end_x, n_points)
    x_points = np.sort(np.random.uniform(low=start_x, high=end_x, size=n_points))
    y_points = np.sin(x_points)

    # Create the SciPy interpolator
    interpolator_scipy = interp1d(x_points, y_points, kind='linear', fill_value="extrapolate")

    # Create our fast-search interpolator
    my_interpolator = FastInterp(x_points, y_points)

    # Prepare for timing comparison
    times = {'scipy': 0.0, 'myclass': 0.0}

    # We'll test interpolation on 3000 points in the same range
    test_points = np.linspace(end_x*.1, end_x*.9, 3000)

    # Evaluate both interpolators and measure time
    for x0 in test_points:
        # SciPy
        start_time = time.time()
        val_scipy = interpolator_scipy(x0)
        end_time = time.time()
        times['scipy'] += (end_time - start_time)

        # Our class
        start_time = time.time()
        val_myclass = my_interpolator(x0)
        end_time = time.time()
        times['myclass'] += (end_time - start_time)

        # Check for mismatch beyond a tolerance

        if abs(val_scipy - val_myclass) > 1e-6:
            print([val_scipy, val_myclass])
            print(f"Mismatch at x={x0:.5f}: scipy={val_scipy}, custom={val_myclass}")
            break


    # Average the times per interpolation call
    for k in times.keys():
        times[k] /= len(test_points)

    # Compare speed
    speedup = times['scipy'] / times['myclass'] if times['myclass'] != 0 else float('inf')

    print("Times per call (sec):", times)
    print("Speedup (SciPy / FastInterp


    ):", speedup)

a = np.arange(5)
a[-4:-2]

